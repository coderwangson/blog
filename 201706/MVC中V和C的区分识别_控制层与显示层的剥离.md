[MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。](http://baike.baidu.com/link?url=Ty_iHrxAgFp-4oGSNIKCixjt3XdUYk_-3MUg-wQMBCQJFuZttVzGXKpBfC693qfZ3-WNjYXLL6FXXN5vJdwoXJNQt3AI9-foOcrYUw86LmbTE74PmuXtHyVewg6HKRl0NYP64Mm4mdwQOG0FBLkYB_) ---百度百科

至于mvc是什么就不再多解释了，在这几天我写的一个小程序中我用到了mvc，但是在刚开始的时候我发现，我其实一直用的是m（v），因为我的代码v和c在很大程度上都没有分开，至于m因为只是一个数据模型，所以现对来说比较好区分，只是m的设计可能不是很合理。
但是对于v和c就不是合理不合理的问题了，而是在于怎么分开，并且在什么时候分开的问题，所以对于v、c的识别是很重要的，我就是走了很多弯路才稍微明白v、c的区别。以下我就依据一个简单的示例分析vc的识别（例子是伪码）。
比如要做一个考题的系统，大概这个样子
![这里写图片描述](http://img.blog.csdn.net/20170605184425496?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjg4ODg4Mzc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
，你要做的就是，点击下一题button后界面能够更新试题与选项，现在数据模型已经有了（是一个存放试题的列表examlist），所以关键就是实现一个点击事件，然后将题显示出来即可。
我第一次的编码大概就是这样：

```

//伪码，不可执行
//按钮点击事件
buttonclick_event(){
showNext();//显示下一题
}
//显示下一题
showNext(){
num++;//因为在列表中，所以只需要用下标就可以，num代表当前试题列表的下标
试题.text = examlist[num].question;//更新试题
选项.text = examlist[num].abcd;//更新选项。。
 .
 .
}
```

这样做其实是没问题的，并且也能完成预期任务，但是关键就在于这样做的话只是现在看来是没问题，但是等到开发到后期，你会发现就有些问题，虽然不是致命的，但是也会使你的代码冗余重复，这里的问题就在于num++ 后的代码其实就已经属于v这个层次了，而对于这个例子其c控制层就一句话num++，c的作用就是控制的作用，**其控制的东西就是数据模型**，所以要将二者分开，这样的好处从当前来看其实就和函数的好处一样，就是不同的函数做不同的事情，各司其职，在长远来看，比如到将来你需要显示问题，但是不需要num++了，或者你有多了一个点击按钮，直接跳三题的功能，这时候你会发现如果你分开的话，就好做多了，因为二者是两个独立的函数，你只需要调用相应的函数就行了，所以分开的好处不言而喻。
下面给出代码

```
//按钮点击事件
//伪码，不可执行
examitem;//如果能够在加一个单道题的数据模型更好
buttonclick_event(){
nextctrl();
nextshow();
}

//c层
nextctrl（）{
num++;
examitem =examlist[num];
}

//v层
nextshow(){
试题.text = examitem.question;//更新试题
选项.text = examitem.abcd;//更新选项。。
}
```

虽然代码长了，但是对以后的开发很有好处，避免出现v、c连在一起的尴尬。
## 总结：
####对于简单的设计来说，c就是控制数据模型的并且将数据模型整合成一个v层能直接使用的数据模型，而v层就是显示的，其作用就仅仅是将数据模型中的内容取出（仅仅取出，连最简单的判断都不需要），并且显示即可。
套用一些设计模式，虽然不能避免出错，但能很大程度上减少你的出错。
